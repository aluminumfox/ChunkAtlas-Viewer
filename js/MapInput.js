/**
 * @file MapInput.js
 *
 * Applies user input events to the map canvas.
 */

// Maximum duration between clicks to register as a double click:
const DOUBLE_CLICK_MS = 300;

class MapInput {
    /**
     * Starts tracking input events for the Minecraft map element.
     *
     * @param mapObject      The MapCanvas object used to manage the map.
     *
     * @param canvasElement  The HTML5 canvas element where the map is drawn.
     */
    constructor(mapObject, canvasElement) {
        assert(mapObject instanceof MapCanvas, "MapInput.constructor: "
                + "mapObject \"" + mapObject + "\" is not a valid MapCanvas.");
        assert(canvasElement instanceof HTMLCanvasElement,
                "MapCanvas.constructor: element \"" + canvasElement
                + "\" is not valid HTMLCanvasElement!");
        this.mapObject = mapObject;
        this.canvasElement = canvasElement;
        this.dragStartPos = null;
        this.mainTouchId = null;
        this.secondaryTouchId = null;
        this.lastClickTime = 0;
        this.listeners = {};
        let handler = this;
        this.addEventListener("wheel", e => handler.scrollEvent(e));
        this.addEventListener("mousedown", e => handler.mouseDown(e));
        this.addEventListener("mouseup", e => handler.mouseUp(e));
        this.addEventListener("touchstart", e => handler.touchStart(e));
        this.addEventListener("touchend", e => handler.touchEnd(e));
    }

    addEventListener(listenerType, callback)
    {
        this.removeEventListener(listenerType);
        this.canvasElement.addEventListener(listenerType, callback);
        this.listeners[listenerType] = callback;
    }

    removeEventListener(listenerType)
    {
        let callback = this.listeners[listenerType];
        if (isDefined(callback)) {
            this.canvasElement.removeEventListener(listenerType, callback);
        }
        this.listeners[listenerType] = undefined;
    }

    //-------- Multipurpose event handling functions: ------------------------
    // Share these between all specific input type handlers.

    /**
     * Applies a multiplier generated by some input event to the current map
     * scale.
     *
     * @param multiplier  A scale multiplication factor, generated from
     *                    something like a mouse wheel or a touch input
     *                    gesture.
     */
    scaleChangeEvent(multiplier) {
        assert(isNumeric(multiplier) && multiplier > 0,
                "MapInput.scaleChangeEvent: invalid scale multiplier \""
                + multiplier + "\"");
        if (multiplier == 1) { return; }
        this.mapObject.updateBounds(this.mapObject.getScale() * multiplier,
                this.mapObject.getCenter());
        this.mapObject.drawMap();
    }

    /**
     *  Handles a new pointer event, such as mousedown or touchstart. 
     *
     * This saves the current pointer position so that it can be used to
     * calculate how far the pointer has moved when the pointer event ends.
     *
     * @param canvasPos  The Point object showing where the pointer event
     *                   occurred.
     */
    pointerStartEvent(canvasPos) {
        assert(canvasPos instanceof Point, "MapInput.pointerStartEvent: "
                + "Invalid canvasPos \"" + canvasPos + "\"");
        const worldPos = this.mapObject.canvasToWorldPos(canvasPos);
        this.dragStartPos = new Point(worldPos.x, worldPos.y);

        // Update last clicked text:
        const blockClicked = new Point(worldPos.x * 16, worldPos.y * 16);
        function insertCommas(numVal, numDecimals) {
            const numStr = numVal.toFixed(numDecimals) + "";
            let lastCommaIdx = numStr.length - ((numDecimals > 0)
                    ? 5 : 6 + numDecimals);
            if (lastCommaIdx <= 0) {
                return numStr;
            }
            let firstCommaIdx = lastCommaIdx % 3;
            if ((numVal < 0 && firstCommaIdx == 1) || firstCommaIdx == 0) {
                // make sure not to put a comma right after the minus sign or
                // at the start of the string.
                firstCommaIdx += 3;
            }
            
            let commaStr = numStr.substr(0, firstCommaIdx);
            for (let i = firstCommaIdx; i <= lastCommaIdx; i += 3) {
                commaStr += ",";
                const charsAdded = (i == lastCommaIdx) ?
                        (numStr.length - i) : 3;
                commaStr += numStr.substr(i, charsAdded);
            }
            return commaStr;
        }
        const xStr = insertCommas(blockClicked.x, 1);
        const zStr = insertCommas(blockClicked.y, 1);
        const blockPosStr = "(" + xStr + ", " + zStr + ")";
        const clickLabel = document.getElementById("lastClicked");
        clickLabel.textContent = "Last Clicked: " + blockPosStr;
        const clickedMapPoint = this.mapObject.getClickedMapPoint();
        const pointLabel = document.getElementById("clickedPoint");
        if (isDefined(clickedMapPoint)) {
            pointLabel.textContent = clickedMapPoint.name + " "
                    + clickedMapPoint.position.multiply(16).toString();
        }
        else {
            pointLabel.textContent = "";
        }
        this.mapObject.drawMap();
    }

    /**
     * Moves the map so that the current held map coordinate is drawn under a
     * specific point on the canvas.
     *
     * @param canvasPos  The canvas point where the held map coordinate will
     *                   be moved to.
     */
    pointerMoveEvent(canvasPos) {
        assert(canvasPos instanceof Point, "MapInput.pointerMoveEvent: "
                + "Invalid canvasPos value \"" + canvasPos + "\"");
        if (this.dragStartPos == null) { return; }
        this.mapObject.scrollChunkToCanvasPt(this.dragStartPos, canvasPos);
        this.mapObject.drawMap();
    }

    /**
     * Triggers when a pointer event ends, whether due to moving outside the
     * canvas bounds, releasing a mouse button, or lifting a finger.
     *
     * @param endCanvasPos  The [x, y] coordinate array storing the position
     *                      within the canvas element where the pointer event
     *                      ended.
     */
    pointerEndEvent(endCanvasPos) {
        assert(endCanvasPos instanceof Point, "MapInput.pointerEndEvent: "
                + "Invalid endCanvasPos value \"" + endCanvasPos + "\"");
        const now = (new Date).getTime();
        const sinceLastClick = now - this.lastClickTime;
        this.lastClickTime = now;
        if (sinceLastClick < DOUBLE_CLICK_MS) {
            this.mapObject.updateBounds(this.mapObject.getScale(),
                    this.mapObject.canvasToWorldPos(endCanvasPos));
            this.mapObject.drawMap();
        }
        this.dragStartPos = null;

    }

    //---------------------- Mouse input handling: ---------------------------
    /**
     * Handle scrolling as a map scaleChangeEvent.
     *
     * @param wheelEvent  The mouse wheel event object.
     */
    scrollEvent(wheelEvent) {
        wheelEvent.preventDefault();
        if (wheelEvent.deltaY == 0) {
            return;
        }
        const multiplier = (wheelEvent.deltaY > 0) ? 0.9 : 1.1;
        this.scaleChangeEvent(multiplier);
    }

    /**
     * Starts tracking mousemove and mouseleave events, then handles the event
     * as a pointerStartEvent.
     *
     * @param mouseEvent  A mouse click event object.
     */
    mouseDown(mouseEvent) {
        const handler = this;
        this.addEventListener("mousemove", e => handler.mouseMove(e));
        this.addEventListener("mouseleave", e => handler.mouseUp(e));
        const canvasPos = this.mapObject.clickedCanvasPoint(mouseEvent, true);
        this.pointerStartEvent(canvasPos);
    }

    /**
     * Handles mouse movement as a pointerMoveEvent.
     *
     * @param mouseEvent  A mouse move event object.
     *
     */
    mouseMove(mouseEvent) {
        const canvasPos = this.mapObject.clickedCanvasPoint(mouseEvent, false);
        this.pointerMoveEvent(canvasPos);
    }

    /**
     *  Scrolls the map when dragged, or centers the map on the clicked spot
     * when double clicked, and saves and shows the final mouse position as
     * the last clicked map coordinate.
     *
     * @param mouseEvent  The mouse click event object created for the mouseup
     *                    event.
     */
    mouseUp(mouseEvent) {
        this.removeEventListener("mousemove");
        this.removeEventListener("mouseleave");
        const canvasPos = this.mapObject.clickedCanvasPoint(mouseEvent, false);
        this.pointerEndEvent(canvasPos);
    }

    // --------------------- Touch Event Handling ----------------------------
    /**
     * Finds the distance between two touch points.
     *
     * @param first   The first Touch object.
     *
     * @param second  The second Touch object.
     *
     * @return        The distance in pixels between both touch objects.
     */
    touchDistance(first, second) {
        const xOffset = first.pageX - second.pageX;
        const yOffset = first.pageY - second.pageY;
        return Math.sqrt(Math.pow(xOffset, 2) + Math.pow(yOffset, 2));
    }

    /**
     * Attempts to find a Touch object within a TouchList.
     *
     * @param touchList  A TouchList object.
     *
     * @param touchId    The identifier of the requested object.
     *
     * @return           The Touch object with the requested ID, or null if the
     *                   object was not found.
     */
    findTouch(touchList, touchId) {
        if (touchId === null)
        {
            return null;
        }
        for (let i = 0; i < touchList.length; i++)
        {
            if (touchList.item(i).identifier === touchId)
            {
                return touchList.item(i);
            }
        }
        return null;
    }

    /**
     * Finds the primary tracked touch point.
     *
     * @param touchList  A TouchList object.
     *
     * @return           The main Touch object, or null if no main touch point
     *                   exists or the main point isn't in the given list.
     */
    findMainTouch(touchList) {
        return this.findTouch(touchList, this.mainTouchId);
    }

    /**
     * Finds the secondary tracked touch point.
     *
     * @param touchList  A TouchList object.
     *
     * @return           The alternate Touch object, or null if no alternate
     *                   touch point exists or the alternate point isn't in the
     *                   given list.
     */
    findSecondaryTouch(touchList) {
        return this.findTouch(touchList, this.secondaryTouchId);
    }

    /**
     * Begins tracking map move/scale events for the first two detected touch
     * inputs.
     *
     * @param touchEvent  The TouchEvent object that triggered this function.
     */
    touchStart(touchEvent) {
        touchEvent.preventDefault();
        let touchList = touchEvent.changedTouches;
        let touchIdx = 0;
        if (this.mainTouchId === null) {
            let newMainTouch = touchList.item(touchIdx);
            this.mainTouchId = newMainTouch.identifier;
            const canvasPos = this.mapObject.clickedCanvasPoint(newMainTouch,
                    true);
            this.pointerStartEvent(canvasPos);
            const handler = this;
            this.addEventListener("touchmove", e => handler.touchMove(e));
            this.addEventListener("touchcancel", e => handler.touchEnd(e));
            touchIdx++;
        }
        if (this.secondaryTouchId === null && touchIdx < touchList.length) {
            let newAltTouch = touchList.item(touchIdx);
            let mainTouch = this.findMainTouch(touchEvent.targetTouches);
            if (mainTouch === null || mainTouch.identifier
                    === newAltTouch.identifier) { return; }
            this.secondaryTouchId = newAltTouch.identifier;
            this.zoomStartDistance = this.touchDistance(mainTouch,
                    newAltTouch);
        }
    }

    /**
     * Uses touch movement events to scroll or scale the map.
     *
     * @param touchEvent  The TouchEvent object that triggered this function.
     */
    touchMove(touchEvent) {
        touchEvent.preventDefault();
        let touchList = touchEvent.changedTouches;
        const mainTouch = this.findMainTouch(touchList);
        const altTouch = this.findSecondaryTouch(touchList);
        assert(mainTouch !== null, "MapInput.touchMove: No main touch object,"
                + " move event should not be triggering!");
        if (mainTouch === null) { return; }
        if (altTouch !== null && this.zoomStartDistance !== null) {
            const newDistance = this.touchDistance(mainTouch, altTouch);
            const scaleChange = newDistance / this.zoomStartDistance;
            this.zoomStartDistance = newDistance;
            this.scaleChangeEvent(scaleChange);
        }
        const canvasPos = this.mapObject.clickedCanvasPoint(mainTouch, false);
        this.mapObject.scrollChunkToCanvasPt(this.dragStartPos, canvasPos);
        this.mapObject.drawMap();
    }

    /**
     * Finishes scaling or dragging the map and stops tracking touch movement
     * when a touch event ends or is cancelled.
     *
     * @param touchEvent  The TouchEvent object that triggered this function.
     */
    touchEnd(touchEvent) {
        touchEvent.preventDefault();
        if (this.mainTouchId === null) { return; }
        let touchList = touchEvent.changedTouches;
        const mainTouch = this.findMainTouch(touchList);
        const altTouch = this.findSecondaryTouch(touchList);
        if (altTouch !== null)
        {
            this.secondaryTouchId = null;
            this.zoomStartDistance = null;
        }
        if (mainTouch !== null)
        {
            this.mainTouchId = null;
            this.removeEventListener("touchmove");
            this.removeEventListener("touchcancel");
            const canvasPos = this.mapObject.clickedCanvasPoint(mainTouch,
                    false);
            this.pointerEndEvent(canvasPos);
        }
    }
}
